{"pages":[],"posts":[{"title":"Java基础1 sleep()和wait()的区别","text":"wait和sleep都会暂停当前线程，对于cpu资源来说，两者都会使cpu将时间片分配给别的线程。 1 用法 sleep是Thread类的方法，wait是Object类的方法。 sleep可以在任何地方使用，而wait只能在同步方法或者同步块中使用。 12345try { Thread.sleep(...);} catch (InterruptedException e) { e.printStackTrace();} 1234Object mon = ...;synchronized (mon) { mon.wait();} 123synchronized (mon) { mon.notify();} 2 资源锁释放 sleep()方法正在执行的线程主动让出CPU（然后CPU就可以去执行其他任务），在sleep指定时间后CPU再回到该线程继续往下执行(注意：sleep方法只让出了CPU，而并不会释放同步资源锁！！！)；wait()方法则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用了notify()方法，之前调用wait()的线程才会解除wait状态，可以去参与竞争同步资源锁，进而得到执行。（注意：notify的作用相当于叫醒睡着的人，而并不会给他分配任务，就是说notify只是让之前调用wait的线程有权利重新参与线程的调度）； 如线程状态图所示，当线程处于running状态，此时线程正在执行，当该线程执行到Thread.sleep()，之后处于阻塞状态，当sleep()时间结束后，此时该线程处于runnable状态，如果之后被cpu选中，则可以继续执行。 如果线程处于running状态，之后开始执行o.wait()方法，此时处于等待队列，在被别的线程唤醒之后，处于锁池中，之后还需要和别的线程竞争锁，获得锁之后，才转为runnable状态，如果之后被cpu选中，则可以继续执行。 下面这段代码具体展示了相关的内容。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.exercise.MultitThread;public class WaitSleepTest { private static class Thread1 implements Runnable { @Override public void run() { synchronized (WaitSleepTest.class){ System.out.println(\"Thread1 开始执行\"); System.out.println(\"Thread1 执行wait\"); try { WaitSleepTest.class.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"Thread1 执行完毕\"); } } private static class Thread2 implements Runnable{ @Override public void run() { synchronized (WaitSleepTest.class){ System.out.println(\"Thread2 开始执行\"); System.out.println(\"Thread2 通知Thread1 开始执行\"); WaitSleepTest.class.notify(); System.out.println(\"Thread2 睡眠10ms\"); try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Thread2 开始执行\"); System.out.println(\"Thread2 执行完毕\"); } } } public static void main(String[] args) { new Thread(new Thread1()).start(); System.out.println(\"主线程 睡眠10ms\"); try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(new Thread2()).start(); System.out.println(\"主线程 执行完毕\"); }} 执行结果 12345678910主线程 睡眠10msThread1 开始执行Thread1 执行wait主线程 执行完毕Thread2 开始执行Thread2 通知Thread1 开始执行Thread2 睡眠10msThread2 开始执行Thread2 执行完毕Thread1 执行完毕 我们在主线程中启动了两个线程，Thread1、Thread2。在Thread1中，通过synchronized的同步方法块中，使用wait()方法，需要注意锁的是类对象。在Thread2中，同样通过synchronized的同步方法块锁住类对象，之后调用了notify()方法，接着调用了sleep()方法。通过执行结果，我们可以发现Thread1遇到wait()方法之后，释放了类锁。因为Thread2使用的是同一把类锁，只有Thread1释放类锁，Thread2才能得到。Thread2在调用notify()方法后，此时Thread1 处于竞争锁的状态。Thread2调用了sleep()方法，在执行完毕后，Thread1才继续执行，说明Thread1在Thread2执行完毕之后才获得了锁。因此，在Thread1执行sleep()方法时，没有释放锁。 3 参考 https://blog.csdn.net/u012050154/article/details/50903326 Java中sleep()与wait()区别 https://www.zhihu.com/question/23328075 java sleep和wait的区别的疑惑?","link":"/2019/07/17/Java基础1-sleep-和wait-的区别/"},{"title":"JVM1 性能调优","text":"JVM参数类型标准参数 在jvm的各个版本基本不变，保持稳定。 -help -server -client -version -showversion -cp -classpath X参数 非标准化参数 -Xint ：解释执行。 -Xcomp ：第一次使用就编译成本地代码。 -Xmixed：混合模式（默认），JVM自己决定是否编译成本低代码。 XX参数 使用比较多。非标准化参数，不稳定，主要用于JVM调优和Debug。 Boolean类型格式：-XX:[+-]表示启用或者禁用name属性。 例如：-XX:+UseConMarkSweepGC -XX:+UseG1GC 非Boolean类型格式：-XX:=表示name的属性的值是value。 例如：-XX:MaxGCPauseMillis=500 -XX:GCTimeRatio=19 查看JVM运行时参数jps查看虚拟机正在运行的进程，并显示虚拟机执行主类。 jinfo实时查看和调整虚拟机各项参数。 jstat查看JVM统计信息监视工具 （１）类加载 （２）垃圾收集 （３）JIT编译","link":"/2019/07/09/JVM1-性能调优/"},{"title":"RocketMQ介绍.md","text":"RocketMQ介绍1、初识RocketMQRocketMQ是阿里巴巴开源的分布式消息中间件，成为 Apache 的顶级项目，以其高性能、低延时和高可靠等特性近年来已经也被越来越多的国内企业使用。 是一个队列模型的消息中间件，具有高性能、高可靠、高实时、分布式特点。 Producer、Consumer、队列都可以分布式。 Producer向一些队列轮流发送消息，队列集合称为Topic，Consumer如果做广播消费，则一个consumer实例消费这个Topic对应的所有队列，如果做集群消费，则多个Consumer实例平均消费这个topic对应的队列集合。 能够保证严格的消息顺序 提供丰富的消息拉取模式 高效的订阅者水平扩展能力 实时的消息订阅机制 亿级消息堆积能力 较少的依赖 2、RocketMQ基于Docker的安装2.0、RocketMQ 物理部署结构 如上图所示， RocketMQ的部署结构有以下特点： Name Server是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。 Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与Name Server集群中的所有节点建立长连接，定时注册Topic信息到所有Name Server。 Producer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。 Consumer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。 根据RocketMQ的部署结构，我们可以发现我们需要安装Name Server和Broker，而Producer和Consumer在Java代码里面产生，不需要我们来部署，此外还有Console的结构进行安装，监控RocketMQ的运行状态。 因此，安装的内容由以下部分构成： Name Server Broker Console 2.1、Name Server的安装 搜索RocketMQ的镜像文件 1docker search rocketmq 拉取镜像文件 1docker pull rocketmqinc/rocketmq 需要注意的是Name Server和Broker使用的是同一个镜像文件 rocketmqinc/rocketmq，而Console使用的镜像文件是 styletang/rocketmq-console-ng 安装镜像 123456docker run -d -p 9876:9876 \\ -v /mydata/rocketmq/namesrv/logs:/root/logs \\ -v /mydata/rocketmq/namesrv/store:/root/store \\ --name rmqnamesrv \\ -e &quot;MAX_POSSIBLE_HEAP=100000000&quot; \\ rocketmqinc/rocketmq sh mqnamesrv -v：宿主机的目录挂在到Docker容器的目录，方便文件的修改和查看。 /mydata/rocketmq/namesrv/logs是宿主机的路径，需要修改成自己配置的路径。 /root/logs是容器的路径。 -p：宿主机和容器的端口的映射。 查看运行状态 1docker ps 当使用 docker ps命令看到有我们安装的镜像文件，即表示安装成功。 2.2、 Broker的安装对于Broker的安装与前面内容类似，只是第三步骤的安装命令可能会不相同。 1234567docker run -d -p 10911:10911 -p 10909:10909 \\-v /mydata/rocketmq/broker/logs:/root/logs \\-v /mydata/rocketmq/broker/store:/root/store \\--name rmqbroker --link rmqnamesrv:namesrv \\-e &quot;NAMESRV_ADDR=namesrv:9876&quot; \\-e &quot;MAX_POSSIBLE_HEAP=200000000&quot; \\rocketmqinc/rocketmq sh mqbroker 2.3、Console的安装对于Console的安装与前面内容类似，只是第三步骤的安装命令可能会不相同。 123docker run -e &quot;JAVA_OPTS=-Drocketmq.namesrv.addr=192.168.113.128:9876 \\-Dcom.rocketmq.sendMessageWithVIPChannel=false&quot; -p 8080:8080 \\--name rmqconsole styletang/rocketmq-console-ng 此时根据我们的配置文件，可以在浏览器访问Console。我的Docker容器IP地址是192.168.113.128，配置文件开放的端口8080， 打开浏览器的192.168.113.128:8080界面。 3、基于Docker安装RocketMQ的爬坑本来以为自己的环境已经弄好了，而且打开Console的地址也有现实，我还是太年轻了。今天下午，想执行执行一个Demo。然后发现Idea一直报异常。org.apache.rocketmq.remoting.exception.RemotingTooMuchRequestException: sendDefaultImpl call timeout在网上找了一些资料，主要原因是连接不上Broker，导致超时报错，归纳一下可能出现的问题。 防火墙的状态是开启的导致端口9876阻塞，只要把防火墙关闭即可。 用Docker容器可能会存在这个原因，因为使用容器启动服务，所以暴露的ip地址使用的是容器的内部地址，而不是容器所在的虚拟机的地址，楼主出现问题的地方就在于此。 归纳一下查找问题的思路吧，虽然走了很多弯路。 我们可以通过Console的界面查看broker暴露的地址。没修改之前是docker容器的地址，大致是172.17.0.8:10911，而正确的地址，应该为Docker容器所在虚拟机的对外IP地址，即为现在的 192.168.113.128:10911 找到问题之后，我们将虚拟机的本地路径挂载到Broker配置文件，并且在启动Broker镜像的时候，指定配置文件的位置，最后把需要修改成的IP地址，修改到挂载文件即可。 在Broker的配置文件 broker.conf添加额外的一行 brokerIP1=192.168.113.128，注意这个IP地址是自己虚拟机的IP地址。 删除之前的镜像文件，重新生成Broker的镜像文件。 12345678docker run -d -p 10911:10911 -p 10909:10909 \\-v /mydata/rocketmq/broker/logs:/root/logs \\-v /mydata/rocketmq/broker/store:/root/store \\-v /mydata/rocketmq/broker/conf/broker.conf:/opt/rocketmq-4.4.0/conf/broker.conf\\--name rmqbroker --link rmqnamesrv:namesrv \\-e &quot;NAMESRV_ADDR=namesrv:9876&quot; \\-e &quot;MAX_POSSIBLE_HEAP=200000000&quot; \\rocketmqinc/rocketmq sh mqbroker -c /opt/rocketmq-4.4.0/conf/broker.conf -c:加载配置文件。","link":"/2019/12/20/RocketMQ介绍-md/"},{"title":"ZooKeeper1-ZooKeeper介绍.md","text":"Zookeeper介绍1、初识ZooKeeper1.1、ZooKeeper介绍Zookeeper是Apache的顶级项目，为分布式应用提供高效且可靠的分布式协调服务。ZooKeeper是一个典型的分布式数据一致性的解决方案。基于他可以实现数据的发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。 ZooKeeper的分布一致性特征如下。 顺序一致性 同一客户端发起的事务请求，会按照发起顺序在ZooKeeper执行。 原子性 事务请求处理的结果在所有集群上都是相同的。 单一视图 无论客户端连接的是哪个ZooKeeper服务器，其数据模型一致。 可靠性 服务端成功执行一个事务，则该事务引起的服务端状态将会保留。 实时性 ZooKeeper仅仅保证在一段时间内，客户端可以从服务器读取到最新数据。 1.2、为什么选择ZooKeeper ZooKeeper在性能、易用性、稳定性方面均达到到了工业级标准。 ZooKeeper是开源的。 ZooKeeper是免费的。 ZooKeeoer得到广泛的应用。 Hadoop、HBase、Storm、Dubbo等软件均使用ZooKeeper作为核心组件，用于分布式协调。 2、安装ZooKeeper2.1、开发环境介绍楼主使用VMware安装的虚拟机，虚拟机系统是CentOS 7的系统。在虚拟机中安装的Docker，所以使用Docker安装ZooKeeper镜像。 2.2、单机部署2.2.1、ZooKeeper的配置文件zoo.cfg。 12345678910111213141516171819202122232425262728293031# The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial# synchronization phase can takeinitLimit=10# The number of ticks that can pass between# sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just# example sakes.dataDir=/datadataLogDir=/datalog# the port at which the clients will connectclientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the# administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to &quot;0&quot; to disable auto purge feature#autopurge.purgeInterval=1server.1=192.168.56.101:2881:3881 配置文件的配置选项含义： tickTime：配置Zookeeper中最小事件单元的长度，很多运行时的时间间隔都是使用tickTime的倍数来表示的。例如，Zookeeper中会话的最小超时时间默认是2*tickTime。 initLimit ：该参数用于配置Leader服务器等待Follower启动，并完成数据同步的时间，默认值10，表示该时间是参数tickTime值的10倍。 syncLimit： 用于配置Leader服务器和Follower之间进行心跳检测的最大延时时间。 dataDir： Zookeeper服务器存储快照文件的目录。 dataLogDir： dataLogDir用于配置Zookeeper服务器存储事务日志文件的目录。 clientPort： clientPort用于配置当前服务器对外的服务器端口，客户端会通过该端口和Zookeeper服务器创建连接，一般设置为2181。每台Zookeeper服务器都可以配置任意可用的端口，同时，集群中的所有服务器不需要保持clientPort端口一致。 server.id=host:port2:port3：id被称为ServerID，用来标识该机器在集群中的机器序号。第一个port表示 端口2用于选举leader，端口3用于集群内通讯使用(Leader会监听此端口) ,Zookeeper实例数应为大于等于3的奇数，如3、5、7…不宜太多。 2.2.2、通过Docker启动ZooKeeper 建立映射文件 在虚拟机的路径下分别建立三个文件夹，conf、data、datalog文件夹，将设置好的zoo.cfg文件放入conf中，另外的两个文件夹保存ZooKeeper生成的快照文件和日志文件。 拉取文件，启动ZooKeeper。 12345678docker run --name zk1 --restart always \\-v /mydata/zookeeper/zk1/data:/data \\-v /mydata/zookeeper/zk1/datalog:/datalog \\-v /mydata/zookeeper/zk1/conf/zoo.cfg:/conf/zoo.cfg \\-p 2181:2181 \\-p 2881:2881 \\-p 3881:3881 \\-d zookeeper 2.3、集群部署集群的部署和单机部署类似，不过需要在zoo.cfg文件的server.id=host:port2:port3配置其他的ZooKeeper应用的配置。","link":"/2019/12/19/ZooKeeper1-ZooKeeper介绍-md/"},{"title":"网络1 计算机网络体系","text":"OSI的七层协议体系结构，概念清楚，理论比较完整，但是复杂不实用；TCP/IP四层体系结构得到广泛的使用；但是在学习计算机网络原理的时，往往将两者结合，使用五层协议的体系结构。 （1）应用层应用层的任务是通过应用进程间的交互来完成特定的网络应用。 应用层协议定义的是应用进程间通信和交互的规则。常见的应用层协议有：DNS、HTTP、SMTP。应用层交互的数据单元称为报文。 （2）传输层传输层的任务是负责向两台主机中进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”指多种应用可以使用同一个传输层服务。传输层有复用和分用的功能。复用指多个应用层进程可以同时使用传输层的服务；分用指传输层把收到的信息分别交付应用层中的相应进程。常见的传输层协议有：TCP、UDP。 TCP（传输控制协议）：提供面向连接的、可靠的数据传输服务。数据传输的单位是报文段。 UDP（用户数据报协议）：提供无连接的、尽最大努力的数据传输服务。数据传输的单位是用户数据报。 （3）网络层网络层的任务（1）负责为分组交换网上的不同主机提供通信服务；（2）选择合适的路由，使源主机传输层传下来的分组，能够通过网络中的路由器找到目的主机。网络层传输的数据单元为分组或包。常见的网络层传输协议IP协议。 （4）数据链路层数据链路层的任务是在两个相邻节点间传输数据时，将网络层的IP数据报组装成帧，在两个节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制）。链路层传输的单位是帧。 （5）物理层物理层的任务是在连接各种计算机的传输媒体上传输数据比特流。物理层传输的单位是比特。","link":"/2019/06/24/网络1 计算机网络体系/"},{"title":"图解Java传递类型","text":"Java的传递类型究竟是值传递还是引用传递，相信大多数小伙伴们都很迷惑，也许有小伙伴知道是值传递，但是不不知道怎么说明。同时这也是一个很经典的面试题，打开文章的你也遇到过吧。 话不多说，先说结论： Java严格按照值传递。 值传递与引用传递 值传递: 在函数调用的过程中，将实参复制一份给形参，在函数中执行的对象是形参。 引用传递: 在函数调用的过程中，将实参的地址传递到函数中，在函数中执行的对象是真实的实参。 首先，我们先弄明白什么值传递和引用传递的具体含义。 值传递，是将我们传递给函数的对象进行复制，而真正传递进函数的是复制的对象，而不是我们传递给函数的对象，所以我们在函数内对于对象的修改，不会影响我们传递给函数的对象(实参)，只会影响形参。 引用传递，是将我们传递给函数的对象的地址传递到函数里面，如果我们在函数中，对对象进行了修改，是会影响我们传递给函数的对象(实参)的。 值传递 引用传递 根本区别 会创建副本 不会创建副本 表现 函数无法改变原始对象 函数可以改变原始对象 代码演示我们可以根据传递给函数的对象的不同，分别演示基本数据类型和引用数据类型的对象 基本数据类型基本数据类型演示代码 123456789101112131415public class ShowCode { public static void main(String[] args) { int a = 1; int b = 2; swap(a, b); System.out.println(&quot;print in main, a = &quot; + a + &quot;, b = &quot; + b); } private static void swap(int a, int b) { int temp = a; a = b; b = temp; System.out.println(&quot;print in swap, a = &quot; + a + &quot;, b = &quot; + b); }} 代码的执行结果： 12print in swap, a = 2, b = 1print in main, a = 1, b = 2 对于这段代码的演示结果，相信屏幕前的你很清楚。当传递参数是基本数据类型的时候，实际传递的参数的副本，所以在swap函数中，对于对象的修改不会影响实际的对象。 引用数据类型引用类型演示代码 12345678910111213141516171819202122232425public class Balloon { private String name; private String color; public Balloon(String name, String color) { this.name = name; this.color = color; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getColor() { return color; } public void setColor(String color) { this.color = color; }} 123456789101112131415161718192021222324252627282930313233343536373839public class PassMain { public static void main(String[] args) { Balloon red = new Balloon(&quot;Red Balloon&quot;, &quot;Red&quot;); Balloon blue = new Balloon(&quot;Blue Balloon&quot;, &quot;Blue&quot;); Balloon yellow = new Balloon(&quot;Yellow Balloon&quot;, &quot;Yellow&quot;); System.out.println(&quot;============= 1 ===============&quot;); swap(red, blue); System.out.println(&quot;Red Balloon color is &quot; + red.getColor()); System.out.println(&quot;Blue Balloon color is &quot; + blue.getColor()); System.out.println(&quot;============= 2 ===============&quot;); swap2(red, blue); System.out.println(&quot;Red Balloon color is &quot; + red.getColor()); System.out.println(&quot;Blue Balloon color is &quot; + blue.getColor()); System.out.println(&quot;============= 3 ===============&quot;); paint(yellow); System.out.println(&quot;Yellow Balloon color is &quot; + yellow.getColor()); } public static void swap(Object o1, Object o2) { Object temp = o1; o1 = o2; o2 = temp; } public static void swap2(Balloon o1, Balloon o2) { String temp = o1.getColor(); o1.setColor(o2.getColor()); o2.setColor(temp); } private static void paint(Balloon balloon) { balloon.setColor(&quot;Black&quot;); balloon = new Balloon(&quot;Green Balloon&quot;,&quot;Green&quot;); balloon.setColor(&quot;White&quot;); }} 代码执行结果 12345678============= 1 ===============Red Balloon color is RedBlue Balloon color is Blue============= 2 ===============Red Balloon color is BlueBlue Balloon color is Red============= 3 ===============Yellow Balloon color is Black 对于这段代码的结果，屏幕面前的你，有没有感觉有点转不过来。哈哈，听我细细道来。 在swap函数中，交换了两个引用数据类型的对象，实际对象没有变化。 在swap2函数中，交换了两个引用数据类型的对象的颜色，实际对象却发生了变化。 在paint函数中，对引用数据类型的对象的颜色，实际对象发生了变化。 底层原理对于值传递，无论是值类型还是引用类型，都会在调用栈上创建一个副本，不同是，对于值类型而言，这个副本就是整个原始值的复制。而对于引用类型而言，由于引用类型的实例在堆中，在栈上只有它的一个引用（一般情况下是指针），其副本也只是这个引用的复制，而不是整个原始对象的复制。 基本数据类型在基本数据类型的代码演示中，根据对象在JVM的分布情况，我们可以知道基本数据类型在栈的分布情况。在基本数据类型对象传递给函数时，会在栈内复制一份，即为形参a，b，在swap函数执行之后，在栈内的分布情况，即变为形参a的值变为2，形参b的值变为1，虽然形参发生了变化，但是实参却没有变化。 引用数据类型在引用数据类型的代码演示中，对于swap函数，o1、o2分别为red、blue的副本，o1、o2分别指向Red Balloon、Blue Balloon对象。在swap函数执行之后o1、o2分别指向Blue Balloon、Red Balloon对象，即指向的对象发生了变化。 swap函数执行前 swap函数执行后 对于swap2函数，o1、o2分别为red、blue的副本，o1、o2分别指向Red Balloon、Blue Balloon对象。在swap2函数执行之后o1、o2分别指向对象的颜色发生变化，即指向的对象发生了变化。 swap2函数执行前 swap2函数执行后 对于paint函数，ballon分别为yellow的副本，ballon、yellow都指向Yellow Balloon对象。在paint函数执行之后yellow先改变了Yellow Balloon对象的颜色，之后指向了Green Balloon对象，最后又改变Green Balloon对象的颜色为白色。 最后我们可以知道，无论是基本数据类型还是引用数据类型的对象，Java都是值传递。 思考题1234567891011public class StringTest { public static void main(String[] args) { String name = &quot;Hello Java&quot;; passStr(name); System.out.println(&quot;name ==&quot; + name); } private static void passStr(String str) { str = &quot;Hello World&quot;; }} 读到这里，预测一下最后打印的是Hello Java还是Hello World？ 最后结果是Hello Java，你猜对了没有？其实想知道结果，只需要知str = &quot;Hello World&quot;和str = new String(&quot;Hello World&quot;)是等价的。剩下的内容，根据我们前面的分析，就可以知道了。","link":"/2020/03/04/图解Java传递类型/"},{"title":"数据库1 事务","text":"事务的基本特性原子性、一致性、隔离性、持久性。（ACID） １ 原子性： 原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样 。 实现方式：在发生异常时，对已经执行的操作进行回滚，在MySQL中，通过回滚日志（undo log）实现。所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。 ２ 一致性： 一致性是指事务使得系统从一个一致的状态转换到另一个一致状态。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。 ３ 隔离性： 多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。 并行时问题： 脏读：事务A修改了一个数据，但未提交，事务B读到了事务A未提交的更新结果，如果事务A提交失败，事务B读到的就是脏数据。 不可重复读：在同一个事务中，对于同一份数据读取到的结果不一致。比如，事务B在事务A提交前读到的结果，和提交后读到的结果可能不同。 幻读：在同一个事务中，同一个查询多次返回的结果不一致。事务A新增了一条记录，事务B在事务A提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录。 隔离级别： Read Uncommitted：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。 Read Committed：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。 Repeated Read：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。 Serialization：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。 实现方式： 锁：锁是一种最为常见的并发控制机制，在一个事务中，我们并不会将整个数据库都加锁，而是只会锁住那些需要访问的数据项， MySQL 和常见数据库中的锁都分为两种，共享锁（Shared）和互斥锁（Exclusive），前者也叫读锁，后者叫写锁。 时间戳：使用时间戳实现事务的隔离性时，往往都会使用乐观锁，先对数据进行修改，在写回时再去判断当前值，也就是时间戳是否改变过，如果没有改变过，就写入，否则，生成一个新的时间戳并再次更新数据，乐观锁其实并不是真正的锁机制，它只是一种思想 。 多版本和快照隔离。 ４ 持久性： 持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 实现方式：与原子性一样，事务的持久性也是通过日志来实现的，MySQL 使用重做日志（redo log）实现事务的持久性，重做日志由两部分组成，一是内存中的重做日志缓冲区，因为重做日志缓冲区在内存中，所以它是易失的，另一个就是在磁盘上的重做日志文件，它是持久的。","link":"/2019/06/27/数据库1-事务/"},{"title":"Java基础2 final关键字","text":"在进行Java编程的时候，我们通常会使用final修饰那些不想改变的数据，这样往往出于效率、设计的目的。final可以修饰类、方法、属性。 1 修饰类 final修饰的类，不能被继承。 1234567891011public class FinalTest { //父类 public final class SuperClass { public SuperClass(){} } //报错：final修饰的类不能被继承。 public final class SubClass extends SuperClass { }} 报错信息： 1Error:(8, 41) java: 无法从最终com.exercise.Blog.FinalTest.SuperClass进行继承 2 修饰方法final修饰的方法，不能被重写。实现final方法的目的： 方法锁定。防止任何继承类修改它的意义和实现。 高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。 1234567891011121314151617181920212223//父类//getName()方法使用final修饰public class SuperClass { public final void getName(){ System.out.println(\"Hello SuperClass\"); }}//子类 //重写父类的被final修饰的getName()方法public class SubClass extends SuperClass { public void getName(){ System.out.println(\"Hello SubClass\"); }}//调用子类的getName()方法public class FinalTest { public static void main(String[] args) { SuperClass sup = new SubClass(); sup.getName(); }} 报错信息： 1Error:(4, 12) java: com.exercise.Blog.SubClass中的getName()无法覆盖com.exercise.Blog.SuperClass中的getName()被覆盖的方法为final ３ 修饰变量基本数据类型 final修饰基本数据类型，当给基本类型初始化之后，不能再重新赋值，否则报错。 12345678910111213public class FinalTest { public static void main(String[] args) { //使用final修饰基本数据类型 final int num = 5; System.out.println(\"num的值为\"+num); //修改基本数据类型的数值 //报错 num = 10; System.out.println(\"num的值为\"+num); }} 报错信息： 1Error:(10, 9) java: 无法为最终变量num分配值 引用数据类型 final修饰引用类型，当final变量初始化之后，final不能重新指向新的变量，但是指向变量的内容可以改变。 12345678910public class FinalTest { public static void main(String[] args) { final StringBuilder str = new StringBuilder(\"yu\"); System.out.println(\"修改前str的值为\"+str); str.append(\"yu\"); System.out.println(\"修改后str的值为\"+str); }} 执行结果： 12修改前str的值为yu修改后str的值为yuyu 在上面的demo中，str刚开始指向yu这个字符串，之后调用append()函数，字符串变为yuyu。但是str的指向没有变化。所以，对于final修饰的引用类型，指向变量的内容可以改变。 12345678910111213public class FinalTest { public static void main(String[] args) { final StringBuilder str = new StringBuilder(\"yu\"); System.out.println(\"修改前str的值为\"+str); str.append(\"yu\"); System.out.println(\"修改后str的值为\"+str); str = new StringBuilder(\"yuNew\"); System.out.println(\"指向别的str的值为\"+str); }} 报错信息： 1Error:(10, 9) java: 无法为最终变量str分配值 在上面的demo中，str刚开始指向yu这个字符串，之后调用append()函数，字符串变为yuyu，接着使用str的指向新的字符串yuNew，产生错误信息。所以，对于final修饰的引用类型，不能重新指向新的变量。 注意 当用final作用于类的成员变量时，成员变量（注意是类的成员变量，局部变量只需要保证在使用之前被初始化赋值即可）必须在定义时或者构造器中进行初始化赋值，而且final变量一旦被初始化赋值之后，就不能再被赋值了。 123456789101112131415161718192021222324252627282930313233343536373839404142public class FinalTest2 { //声明时直接初始化 private final static int i = 0; //构造函数赋值（在构造代码块之后执行） private final int j; //静态代码块中赋值（先于构造代码块执行） private final static int k; //构造代码块中赋值（先于构造函数执行） private final int m; //正确// public FinalTest2(int j) {// this.j = j;// } //正确 public FinalTest2() { this.j = 1; } //静态代码块 static { k = 2; } //构造代码块 { m = 3; } public static void main(String[] args) { FinalTest2 n = new FinalTest2(); System.out.println(\"声明时直接初始化的i值为\"+i); System.out.println(\"构造函数赋值的j值为\"+n.j); System.out.println(\"静态代码块赋值的k值为\"+k); System.out.println(\"构造代码块赋值的m值为\"+n.m); }} 1234声明时直接初始化的i值为0构造函数赋值的j值为1静态代码块赋值的k值为2构造代码块赋值的m值为3 参考 https://zhuanlan.zhihu.com/p/33083924 深入浅出Java final关键字 https://www.cnblogs.com/dolphin0520/p/3736238.html 浅析Java中的final关键字 https://blog.csdn.net/u010002184/article/details/81347110 java,final变量初始化方式","link":"/2019/07/20/Java基础2-final关键字/"},{"title":"数据库2 索引","text":"一、索引的概念 索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。 二、索引的特点 1.索引可以加快数据库的检索速度 2.索引降低了数据库插入、修改、删除等维护任务的速度 3.索引创建在表上，不能创建在视图上 4.索引既可以直接创建，也可以间接创建 5.可以在优化隐藏中，使用索引 6.使用查询处理器执行SQL语句，在一个表上，一次只能使用一个索引 三、索引的优点 1.创建唯一性索引，保证数据库表中每一行数据的唯一性 2.大大加快数据的检索速度，这也是创建索引的最主要的原因 3.加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 4.在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 5.通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。 四、索引的缺点 1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加 2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大 3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度 五、应该建立索引的情况 1.在经常需要搜索的列上，可以加快搜索的速度； 2.在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构； 3.在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度； 4.在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的； 5.在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； 6.在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 六、不应该建立索引的情况 1.对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 2.对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 3.对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 4.当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。 七、索引建立的原则 1. 在经常用作过滤器的字段上建立索引； 2. 在SQL语句中经常进行GROUP BY、ORDER BY的字段上建立索引； 3. 在不同值较少的字段上不必要建立索引，如性别字段； 4. 对于经常存取的列避免建立索引； 5. 用于联接的列（主健/外健）上建立索引； 6. 在经常存取的多个列上建立复合索引，但要注意复合索引的建立顺序要按照使用的频度来确定； 7. 缺省情况下建立的是非簇集索引，但在以下情况下最好考虑簇集索引，如：含有有限数目（不是很少）唯一的列；进行大范围的查询；充分的利用索引可以减少表扫描I/0的次数，有效的避免对整表的搜索。当然合理的索引要建立在对各种查询的分析和预测中，也取决于DBA的所设计的数据库结构。","link":"/2019/06/28/数据库2-索引/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/05/26/hello-world/"},{"title":"网络2 HTTP","text":"1 http请求报文和响应报文​ （1）http请求报文由请求行、请求头部、空行、请求数据组成。 ​ 请求行：（请求方法，url中的path路径，http版本） ​ 请求头部（header）：关键字/值对组成 ​ （2）http响应报文由状态行、响应头部、空行、响应数据组成。 ​ 状态行：（http版本，状态码，状态码描述） ​ 响应头部（header）：关键字/值对组成 2 http请求方法GET：获取资源。请求访问已被URI识别的资源。 POST：传输实体主体。 PUT：传输文件。 HEAD：获得报文的首部。与GET一样，但是不返回报文主体。 DELETE：删除文件。与PUT相反。PUT和DELETE方法本身不带有验证机 制，所以一般的网站不使用这两种方法。 OPTIONS：询问支持的方法。 TRACE：追踪路径。 3 Get和Post区别语义区别： get获取数据，post提交数据。 规范： （1）get把参数写在url中，post通过请求体传参。实际上，http协议没有要求，HTML中有类似的定义，所以后来浏览器实现了。 （2）get请求url中传递的参数长度有限制，post没有。实际上，http协议没有要求，主要出于浏览器和服务器的性能方面的考虑。 （3）安全性。 区别（http协议方面） （1）安全。是否改变服务器状态。 （2）幂等性。重复提交是否有意外情况发生。 （3）缓存。get有缓存，post没有缓存。 4 http状态码 典型的状态码及其语义 100 继续请求者应当继续提出请求 200 成功。 201 已创建。请求成功并且服务器创建了新的资源。 204 无内容。服务器对于客户端没有返回新的信息。 206 部分内容。客户端进行了范围请求，服务器成功执行get请求。 301 永久移动。 302 临时移动。与301的区别，临时性质。例如用户把URI保存书签，301会更新书签，302不会。 303 查看其它位置。由于请求位置存放另一个URI，应该使用GET方法定向获取请求资源。 304 未修改。 400 请求错误。服务器不理解请求语法。 401 未授权。需要身份认证。 403 禁止。服务器禁止请求。 404 未找到。服务器找不到请求的网页。 500 服务器内部错误。 503 服务不可用。 5 http版本的区别http1.0和http1.1的区别（1）长连接 HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连。HTTP是基于TCP/IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求 。 （2）节约宽带 HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。 另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。 （3）HOST域 现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。 HTTP1.0是没有host域的，HTTP1.1才支持这个参数。 http1.1和http2.0的区别（1）多路复用 HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。当然HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。 TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。 （2）数据解锁 HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。 （3）服务器推送 当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。 服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。","link":"/2019/06/26/网络2-HTTP/"},{"title":"数据库3 索引数据结构","text":"为什么要有B树？ 计算机有一个局部性原理，就是说，当一个数据被用到时，其附近的数据也通常会马上被使用。所以当你用红黑树的时候，你一次只能得到一个键值的信息，而用B树，可以得到最多M-1个键值的信息。这样来说B树当然更好了。 另外一方面，同样的数据，红黑树的阶数更大，B树更短，这样查找的时候当然B树更具有优势了，效率也就越高。 一、B树B树的结构要求： 1）根节点至少有两个子节点 2）每个节点有M-1个key，并且以升序排列 3）位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间 4）其它节点至少有M/2个子节点 5）所有叶子节点都在同一层 二、B+树B+树是B-树的变体，也是一种多路搜索树： 1.其定义基本与B-树同，除了根节点： 2.非叶子结点的子树指针与关键字个数相同； 3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）； ４.为所有叶子结点增加一个链指针； ５.所有关键字都在叶子结点出现； 三、B*树 B*树是对B+树进行的又一次的升级。在B+树的非根和非叶子结点再增加指向兄弟的指针； 四、MySQl中索引的数据结构1、MyISAM引擎 MyISAM中有两种索引，分别是主索引和辅助索引，在这里面的主索引使用具有唯一性的键值进行创建，而辅助索引中键值可以是相同的。MyISAM分别会存一个索引文件和数据文件。它的主索引是非聚集索引。当我们查询的时候我们找到叶子节点中保存的地址，然后通过地址我们找到所对应的信息。 2、InnoDB引擎 InnoDB索引和MyISAM最大的区别是它只有一个数据文件，在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点数据域保存了完整的数据记录。所以我们又把它的主索引叫做聚集索引。而它的辅助索引和MyISAM也会有所不同，它的辅助索引都是将主键作为数据域。所以，这样当我们查找的时候通过辅助索引要先找到主键，然后通过主索引再找到对于的主键，得到信息。 因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。 InnoDB索引和MyISAM索引的区别： 一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。 二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。","link":"/2019/06/28/数据库3-索引数据结构/"},{"title":"图解Java内存区域","text":"上一篇文章中，我们提到了对象在内存中的分布情况，图解Java传递类型，那么在这篇文章中，我会用比较通俗易懂的方式，讲解一下Java的内存和对象的内存分布情况。 Java内存区域## Java是一座围城，Java开发不需要像C、C++开发人员那样，维护每个对象从开始到终结的职责。因为Java虚拟机会帮助我们完成这些职责，但是一旦发生内存泄漏和溢出，就需要我们排查。 Java虚拟机执行Java程序时，把它管理的整个内存区域称为运行时数据区。同时根据区域的用途，以及创建和销毁时间等因素，将运行时数据区分成不同的区域。 程序计数器程序计数器表示当前线程所执行字节码指令的行号计数器。字节码解释器通过改变程序计数器的值，选取下一条需要执行的指令。为了保证线程切换之后恢复到正确的执行位置，每条线程都需要独立的程序计数器，所以程序计数器是线程私有的。同时程序计数器是唯一一个在虚拟机规范中没有规定OutOfMemoryError的区域。 注：线程执行Java方法，程序计数器记录字节码指令地址；如果执行的是本地(Native)方法，程序计数器为空。 虚拟机栈虚拟机栈是Java方法执行的线程内存模型。每个方法的执行，Java虚拟机都会创建一个栈帧存储方法相关变量。每个方法被调用到执行完毕的过程，对应栈帧在虚拟机栈中入栈到出栈的过程。 如下图所示，当虚拟机执行swap(a,b)方法时，会创建一个单独的栈帧swap(a,b)栈帧，在该栈帧中会存储于方法相关的变量，该栈帧的入栈和出栈操作对应着方法的执行和结束。 每个栈帧都包含了局部变量表、操作数、动态链接、方法返回值。 局部变量表：存放方法参数和内部定义的局部变量。局部变量表的容量以变量槽为最小单位每个变量槽可以存放一个boolean、byte、char、short、int、float、reference、returnAddress数据类型。 操作数栈：底层也是栈结构，是进行数据运算的地方。 当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。 动态链接：将常量池中指向方法的部分符号引用，在方法运行期间转为直接引用。 字节码中的方法调用指令就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。 返回地址：方法执行退出后，返回到方法被调用的地方。 在swap函数执行的过程中，a、b、temp都会保存到局部变量表中，其中的赋值操作则通过操作数栈执行， 方法执行完毕返回到调用的地方的地址则存储在返回地址中。 本地方法栈本地方法栈与 Java 虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的 Native 方法服务。 Java堆Java堆是虚拟机管理的内存中最大的一块，几乎所有对象都在Java堆分配内存。Java堆在虚拟机启动的时候创建，被所有的线程共享。Java堆也会涉及到内存回收的内容，本片文章先不展开了。Java堆无法扩展时，会报出OutOfMemoryError异常。 方法区方法区存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码缓存等数据。方法区是各个线程共享的内存区域。 屏幕面前的你，会不会遇到这样的困惑。方法区和永久代有什么关系？和元空间呢？ 方法区和永久代的关系 方法区是JVM规范概念，而永久代则是HotSpot虚拟机特有的概念。 *《Java虚拟机规范》只是规定了有方法区的概念和作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 同时大多数用的JVM都是Sun公司的HotSpot。在HotSpot上把GC分代收集扩展至方法区，或者说使用永久代来实现方法区。因此永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现。其他的虚拟机实现并没有永久带这一说法。在1.7之前在(JDK1.2 ~ JDK6)的实现中，HotSpot 使用永久代实现方法区，HotSpot 使用 GC分代来实现方法区内存回收，可以使用如下参数来调节方法区的大小。* 元空间 对于Java8， HotSpots取消了永久代，取代永久代的就是元空间。永久代存在内存上限(`-XX:MaxPermSize`，即使不设置也有默认大小)，当进程申请不到足够的内存，会造成内存溢出。改成元空间后，改用本地内存，只要本地空间足够，就不会有内存溢出的问题。 *元空间和永久代有什么不同的？* *存储位置不同，永久代物理是是堆的一部分，和新生代，老年代地址是连续的，而元空间属于本地内存；* *存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中。* 运行时常量池运行时常量池是方法区的一部分，是一块内存区域。Class 文件常量池将在类加载后进入方法区的运行时常量池中存放。一个类加载到 JVM 中后对应一个运行时常量池。 易混淆的概念 屏幕面前的你，会不会遇到这样的困惑。运行时常量池和Class文件常量池有什么关系？和字符串常量池呢？和缓冲池呢？ Class文件常量池Class 文件常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。常量池中主要存放两大类常量：字面量和符号引用。当Class文件常量池加载到方法区时，会把符号引用转换为直接引用，存放到运行时常量池。 字符串常量池字符串常量池是全局的，JVM 中独此一份，因此也称为全局字符串常量池。 其中： 在 jdk1.6（含）之前也是方法区的一部分，并且其中存放的是字符串的实例；在 jdk1.7（含）之后是在堆内存之中，存储的是字符串对象的引用，字符串实例是在堆中； 底层原理 在HotSpot VM里实现线程池功能的是一个StringTable类，它是一个Hash表，默认值大小长度是1009；这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。字符串常量由一个一个字符组成，放在了StringTable上。 123String str1 = &quot;图解Java&quot;;String str2 = new String(&quot;图解Java&quot;);System.out.println(str1 == str2); 在这段代码中，当执行String str1 = &quot;图解Java&quot;时，先到常量池中查询有没有&quot;图解Java&quot;字符串的引用，如果没有，则会在Java堆上创建&quot;图解Java&quot;字符串，在常量池中存储字符串的地址，str1则指向字符串常量池的地址。 String str2 = new String(&quot;图解Java&quot;)，则会直接在Java堆中创建对象。str2指向堆中的地址。 看到这里，屏幕面前的你有没有想到最后的结果是false呢。 如果此时还有String str3 = &quot;图解Java&quot;那么str1==str3的结果是什么？ 此时str3发现字符串常量池中已经有了&quot;图解Java&quot;字符串的引用，则直接返回，不会创建新的对象。 看到这里，屏幕面前的你有没有想到最后的结果是true呢。 JVM中除了字符串常量池，8种基本数据类型中除了两种浮点类型剩余的6种基本数据类型的包装类，都使用了缓冲池技术，但是 Byte、Short、Integer、Long、Character 这5种整型的包装类也只是在对应值在 [-128,127] 时才会使用缓冲池，超出此范围仍然会去创建新的对象。 Class文件常量池、运行时常量池、字符串常量池的联系我们平时写好的Java代码即Java格式的文件，经过编译，会变成Class类型的文件。而Class文件有一部分是Class文件常量池，用于存储字面量和符号引用。 Class文件经过类加载器加载后，之前Class文件常量池的内容会存放到方法区的运行时常量池，需要注意的是Class文件常量池的符号引用会转变直接引用存入运行时常量池。 字符串常量池是JVM的一部分，整个JVM只有一份，在将Class文件常量池的字面量也会在类加载的时候进入到字符串常量池中。 份数 内容 Class文件常量池 每个类对应一份 字面量、符号引用 运行时常量池 每个类对应一份 字面量、直接引用 字符串常量池 整个JVM仅有一份 字符串","link":"/2020/03/06/图解Java内存区域/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"多线程","slug":"多线程","link":"/tags/多线程/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"性能调优","slug":"性能调优","link":"/tags/性能调优/"},{"name":"RocketMQ","slug":"RocketMQ","link":"/tags/RocketMQ/"},{"name":"ZooKeeper","slug":"ZooKeeper","link":"/tags/ZooKeeper/"},{"name":"网络","slug":"网络","link":"/tags/网络/"},{"name":"图解","slug":"图解","link":"/tags/图解/"},{"name":"数据库","slug":"数据库","link":"/tags/数据库/"},{"name":"事务","slug":"事务","link":"/tags/事务/"},{"name":"基础","slug":"基础","link":"/tags/基础/"},{"name":"索引","slug":"索引","link":"/tags/索引/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"}],"categories":[]}